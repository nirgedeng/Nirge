--------------------------------------

网络，，，，，，

缓冲区分配，，，
	CACHE 存在，收发都从这里拿缓冲区，完事了还回去，减少内存分配，
拷贝，，，
	发，借 CACHE 内存序列化一次，到网络缓冲区一次，
	收，到循环缓冲区一次，借 CACHE 内存切出来一次，反序列化，
核心，，，
	收、发独立，
	收、发量限流，防止过度占用资源，
	CACHE 限制总体使用量，10M 对应百兆带宽，1G 对应万兆带宽，
	FILL 找个包处理器，
	PKG 做序列化、反序列化工作，支持不同类型 PKG，目前支持 ARRAY、PROTOBUF，可扩展支持 THRIFT、JSON，
	HEAD 目前未开放定制，本质上支持定制，这东西定制了兼容现存网络库，对应不同的分帧协议，
    加密、压缩，目前未支持，序列化后 CACHE 借来的缓冲是完整的，反序列化后切出来的 CACHE 也是完整的，基于此套上加密、压缩流即可，

--------------------------------------

RPC，，，，，，

CALLER，，，
	支持一次性调用、等待回包的调用，
	跟 ASYNC/AWAIT 机制整合，支持异步代码同步化，
	采用异常方式，上端负责 TRY 包裹粒度，
	存根保留调用凭证，支持超时、主动打断，有限流，
	
CALLEE，，，
	挂接服务，
	内部错误以异常方式回报 CALLER，
	正常、错误考虑回包中加以区分，如此怎么也有个回执结果，要么系统异常方式，要么调用回包方式，

核心，，，
	跟网络弱耦合，本质上仅是调用简化，插接到现有网络体系上即可，
	服务器可以作为 SERVICE，客户端同样可以作为 SERVICE，客户端集考虑提供定制化的 TRANSFER 做到仅一个 CALLER，
	客户端作为 SERVICE 可以用来遥控界面显示、收集用户数据等，

工具，，，
    服务描述包含参数返回值定义、服务自身描述，
    无论服务是否集中在一个 PROTO 文件，服务接口、CALLER、CALLEE 都是单独文件，参数返回值默认文件，
    针对 A 即 A.cs ARpcCaller.cs IARpcService.cs ARpcCallee.cs  几个文件，第一个是公共的，二是客户端需要的，三、四是服务器需要的，

--------------------------------------
--------------------------------------
--------------------------------------
--------------------------------------
--------------------------------------
--------------------------------------
